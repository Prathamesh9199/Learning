# üß† Neuro-Symbolic SQL Data Agent
A Dual-Brain Architecture for Semantic Data Analysis

This repository houses a Human-in-the-Loop (HITL) SQL Data Analysis Agent that solves the "Hallucination" and "Context" problems of traditional Text-to-SQL systems.

It utilizes a Dual-Brain Architecture:
- **Right Brain (Business Analyst)**: A Knowledge Graph (KG) engine that understands vague business terms, relationships, and organizational context.
- **Left Brain (Data Engineer)**: A strict SQL execution engine that maps those concepts to precise Stored Procedures.

## üèóÔ∏è The Biological Architecture

The core philosophy of this agent is mapped to biological cognitive systems. This separation of concerns allows the agent to "think" about the business domain before it attempts to "execute" code.

### 1. üé® The Right Brain: Business Analyst (Exploration)
**Code Path**: `resources/kg/`, `nodes/kg_*.py`  
**Role**: Creativity, Association, Context.  
**Function**: When a user asks "Why is profit low?", the Right Brain doesn't look at the database. It looks at the Knowledge Graph. It understands that "Profit" isn't a table, but a concept (GrossIncome) calculated via Sale - COGS. It understands that "Mandalay" is a City entity.  
**Tools**: Fuzzy Search, Neighbor Traversal, Path Finding (NetworkX).

### 2. üìê The Left Brain: Data Engineer (Execution)
**Code Path**: `client/sql_manager.py`, `nodes/sql_*.py`  
**Role**: Logic, Precision, Execution.  
**Function**: Once the Right Brain defines the context, the Left Brain takes over. It ignores vague terms and executes specific, pre-approved Stored Procedures defined in the Registry. It handles parameter validation, dependency resolution, and strict SQL syntax.  
**Tools**: SQLServerClient, Stored Procedure Registry, Pydantic Validation.

### 3. ‚ö° The Nervous System: LangGraph (Wiring)
**Code Path**: `agent/graph.py`  
**Role**: Signal Transmission, Coordination.  
**Function**: This is the wiring that connects the two brains. It routes signals (State) from the User $\to$ Right Brain $\to$ Context Bridge $\to$ Left Brain $\to$ User. It handles conditional routing (loops, retries, handovers).

### 4. üíæ The Memory: AgentState (Storage)
**Code Path**: `agent/state.py`  
**Role**: Short-term Working Memory.  
**Function**: A typed dictionary that holds the current "thought process."
- `kg_plan`: What the Right Brain intends to explore.
- `business_context`: The bridge insight (e.g., "Profit maps to GrossIncome").
- `sql_plan`: The precise execution steps generated by the Left Brain.
- `results`: Raw data returned from tools.

## üìÇ Directory Structure

```
/project_root
‚îÇ
‚îú‚îÄ‚îÄ app.py                   # üñ•Ô∏è THE FRONTEND (Streamlit UI)
‚îú‚îÄ‚îÄ main.py                  # ‚öôÔ∏è CLI Entry Point (Headless mode)
‚îú‚îÄ‚îÄ config.py                # üîê Configuration & Secrets
‚îú‚îÄ‚îÄ graph_build.py           # üõ†Ô∏è Utility to generate the Knowledge Graph JSON
‚îú‚îÄ‚îÄ supermarket_kg.json      # üï∏Ô∏è The Serialized Knowledge Graph
‚îÇ
‚îú‚îÄ‚îÄ client/                  # üîå MANAGERS (The Hands & Eyes)
‚îÇ   ‚îú‚îÄ‚îÄ llm_manager.py       # OpenAI / LLM Configuration
‚îÇ   ‚îú‚îÄ‚îÄ sql_manager.py       # SQL Server Connection & Execution logic
‚îÇ   ‚îî‚îÄ‚îÄ kg_manager.py        # NetworkX Graph Logic & Fuzzy Search
‚îÇ
‚îú‚îÄ‚îÄ resources/               # üì¶ RESOURCES (The Knowledge)
‚îÇ   ‚îú‚îÄ‚îÄ registry/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sql_sp.py        # üìñ The Registry of allowed Stored Procedures
‚îÇ   ‚îú‚îÄ‚îÄ kg/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ data.json        # Raw Knowledge Graph Data source
‚îÇ   ‚îú‚îÄ‚îÄ schema/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pydantic_schemas.py  # üìù Data Contracts & Type Definitions
‚îÇ   ‚îî‚îÄ‚îÄ state.py             # üß† The AgentState (Memory Definition)
‚îÇ
‚îî‚îÄ‚îÄ agent/                   # ü§ñ THE AGENT (The Brains)
    ‚îú‚îÄ‚îÄ graph.py             # ‚ö° The Nervous System (LangGraph wiring)
    ‚îî‚îÄ‚îÄ nodes/               # üß† Individual Cognitive Nodes
        ‚îú‚îÄ‚îÄ kg_planner.py    # Right Brain: Strategy
        ‚îú‚îÄ‚îÄ kg_executor.py   # Right Brain: Action
        ‚îú‚îÄ‚îÄ context_refiner.py # üåâ The Bridge (Translator)
        ‚îú‚îÄ‚îÄ sql_planner.py   # Left Brain: Strategy
        ‚îú‚îÄ‚îÄ sql_executor.py  # Left Brain: Action
        ‚îú‚îÄ‚îÄ responder.py     # Voice: Final Synthesis
        ‚îú‚îÄ‚îÄ error_handler.py # Resilience: Retry Logic
        ‚îî‚îÄ‚îÄ human_review.py  # Oversight: HITL Logic
```

## üåä Workflow Logic (The Thought Process)

The agent follows a strict Dual-Phase workflow ensuring no SQL is written without semantic grounding.

```
graph TD
    Start([User Query]) --> Phase1
    
    subgraph Phase1 [Right Brain: Business Analysis]
        KG_Planner[KG Planner] --> KG_Exec[KG Executor]
        KG_Exec -- Found Info --> Context[Context Refiner]
        KG_Exec -- Need More --> KG_Planner
    end

    Context -- "Business Context" --> Phase2

    subgraph Phase2 [Left Brain: Data Analysis]
        SQL_Planner[SQL Planner] --> Review{Human Review}
        
        Review -- Approved --> SQL_Exec[SQL Executor]
        Review -- Rejected --> SQL_Planner

        SQL_Exec -- Success --> Responder[Responder]
        SQL_Exec -- Error --> ErrorHandler[Error Handler]
    end

    Responder --> End([Final Insight])
```

1. **Exploration (Right Brain)**: The agent fuzzy searches the graph for user terms. It traverses edges to find relationships (e.g., Customer $\to$ INITIATES $\to$ Sale).
2. **Refinement (The Bridge)**: The ContextRefiner node summarizes the graph findings into a natural language "Business Context" (e.g., "User is asking about 'Profit'. In our schema, Profit is GrossIncome. Location refers to City.").
3. **Planning (Left Brain)**: The SQLPlanner receives this context. It looks up the SP_REGISTRY. It realizes it cannot execute SELECT * FROM Profit, so it chooses sp_GetGrossIncome based on the context.
4. **Execution (Left Brain)**: The SQLExecutor runs the stored procedure securely via pyodbc.
5. **Synthesis**: The Responder combines the raw data + business context to answer the user.

## üöÄ Installation & Setup

### 1. Prerequisites
- Python 3.10+
- SQL Server (or Azure SQL) with ODBC Driver 17.
- OpenAI API Key (GPT-4o recommended for reasoning).

### 2. Environment Setup

```bash
# Clone the repository
git clone <your-repo>
cd dual-brain-agent

# Create Virtual Environment
python -m venv .venv
source .venv/bin/activate  # Mac/Linux
# .venv\Scripts\activate   # Windows

# Install Dependencies
pip install langchain langgraph pydantic-ai networkx pyodbc openai streamlit
```

### 3. Configuration (.env & config.py)

Ensure config.py has the correct credentials. You can set these as Environment Variables or hardcode them for local dev (not recommended for prod).

```python
# config.py
SERVER = 'YOUR_SERVER_ADDRESS'
DB_NAME = 'SupermarketDB'
USER = 'sa'
PASSWORD = 'your_strong_password'
OPENAI_API_KEY = "sk-..."
```

### 4. Build the Knowledge Graph

Before running the agent, you must compile the semantic graph from the definitions.

```bash
python graph_build.py
# Output: ‚úÖ SUCCESS: Graph exported to 'supermarket_kg.json'
```

## üñ•Ô∏è Usage

### Option A: The Streamlit UI (Recommended)

This provides the full "Dual-Brain" experience with visual logs distinguishing between business logic (Blue) and SQL logic (Orange).

```bash
streamlit run app.py
```

**Key UI Features:**
- **Reasoning Toggle**: Switch between "Fast" (Low temp) and "Deep Think" (High reasoning effort).
- **Thought Stream**: Expand the "Process Details" to see the Right Brain exploring concepts before the Left Brain writes code.
- **Human-in-the-Loop**: The agent creates a plan and pauses. You must type "Yes" to approve the SQL execution.

### Option B: The CLI (Headless)

For quick testing or API integration.

```bash
python main.py
```

## üõ°Ô∏è Security & Registry (The Left Brain Constraints)

This agent DOES NOT generate raw SQL (SELECT * FROM...). This is a security feature, not a bug. It uses a Strict Registry pattern.

### Why?
- **No Injection**: Impossible to inject malicious SQL if the agent can only call sp_GetSales.
- **Optimized Queries**: DBAs write the Stored Procedures; the AI just calls them.
- **Governance**: You control exactly what data is exposed.

### Adding a New Capability

To give the agent a new skill, you don't prompt it. You add code.

1. **Create the SP in SQL Server:**
```sql
CREATE PROCEDURE sp_GetTopProducts (@Category NVARCHAR(50)) ...
```

2. **Register it in `resources/registry/sql_sp.py`:**
```python
"sp_GetTopProducts": StoredProcedure(
    name="dbo.sp_GetTopProducts",
    description="Gets top 5 products by revenue for a category.",
    parameters={
        "Category": ParameterDetail(description="Product line name")
    },
    returns="..."
)
```

The SQLPlanner will immediately be aware of this tool and know when to use it based on the Right Brain's context.

## üß† Knowledge Graph (The Right Brain Logic)

The Knowledge Graph is built using NetworkX. It is defined in `graph_build.py`.

### Nodes (Concepts)
- Sale (Hub Node)
- GrossIncome, Tax, COGS (Metrics)
- City, Branch (Dimensions)

### Edges (Relationships)
- Sale $\xrightarrow{YIELDS}$ GrossIncome
- Branch $\xrightarrow{LOCATED\_IN}$ City

### How the Planner uses it

If the user asks: **"Tax trends in Mandalay"**

1. **Fuzzy Search**: Finds Tax (Node) and Mandalay (City Node).
2. **Pathfinding**: Finds path Tax $\leftarrow$ INCURS $\leftarrow$ Sale $\xrightarrow{OCCURS\_AT}$ Branch $\xrightarrow{LOCATED\_IN}$ City.
3. **Insight**: "To find Tax for Mandalay, we must aggregate Sales incurred at Branches located in Mandalay."

## üõ†Ô∏è Error Handling (Resilience)

The system implements a robust `error_handler.py` node:

- **Auto-Retry (Attempts 1-2)**: If pyodbc throws a transient error (timeout), the agent retries automatically.
- **Human Help (Attempt 3)**: The agent PAUSES and asks the user: "I tried twice but got Error X. Can you clarify the parameter?"
- **Final Attempt (Attempts 4-5)**: Once the user provides input, it retries with the new info.
- **Fail**: Graceful degradation if the task is impossible.

## üîÆ Roadmap

- **v1.5**: Dynamic KG updates (Agent can add new synonyms to the graph based on user feedback).
- **v2.0**: Vector Database integration for "Long Term Memory" (remembering user preferences across sessions).
- **v2.5**: Multi-Agent setup where the Right Brain and Left Brain are separate LLM fine-tunes (e.g., GPT-4o for Business, fine-tuned Llama 3 for SQL).

## ü§ù Contributing

1. Fork the repo.
2. Create your feature branch (`git checkout -b feature/AmazingFeature`).
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`).
4. Push to the branch (`git push origin feature/AmazingFeature`).
5. Open a Pull Request.

---

Built with ‚ù§Ô∏è using LangGraph & Streamlit